---
layout: post
title: Google Summer of Code 2018 - Report
subtitle: Coding phase starts!
image: /img/cern-logo-blue.png
gh-repo: ntauth/yampl
gh-badge: [star, fork, follow]
tags: [gsoc]
---
![CERN-HSF](/img/gsoc-cern-hsf.png)


So here we go! The coding phase of this year's round of **Google Summer of Code** has officially started on May 14th, and I'm so itching to see how this is going to evolve.
I was officially accepted to GSoC on April 23 to work with **CERN-HSF** on a very interesting project. For those of you who don't know, "the HSF is the umbrella organisation that encourages cooperation and common development of software in High Energy Physics".

YAMPL (Yet Another Message Passing Library)
===========================================
This year I'm working on [YAMPL](https://github.com/ntauth/yampl) (Yet Another Message Passing Library), an Inter-proces and inter-thread communication library used by **CERN** as part of the **ATLAS** experiment. The library leverages different communication strategies (Shared Memory, Pipes, ZeroMQ) to achieve maximum performance and reliability, but it does have some shortcomings. The objective of this project is to modernize the library by conceiving and implementing a plugin framework which would allow for runtime selection of these communication strategies (implemented as dynamic shared modules). This would make YAMPL extremely modular and flexible, while being totally decoupled from the other parts of the code. In brief, what are the benefits?
- Lean and lightweight core library, which makes it easier for developers to make important changes to the core code without worrying about jeopardizing compatibility with the modules
- Developers can develop a wide array of different plugins, including but not limited to the socket backends (the communication strategies we talked about earlier). Each plugin must adhere to a strict contract so that the core library can operate without worrying about whether the plugin code is actually compatible or not.

But there's more to it than that! YAMPL can be used by Python by leveraging the C++ bindings generated by CPython. However, the bindings and the core library are stored in different places, which implies regenerating bindings in a rather cumbersome fashion: pull the changes from the core YAMPL repository, clone the YAMPL bindings repository, generate the new bindings and, finally, install them. This leads us to the second objective: implement a new procedure that seamlessly generates up-to-date Python bindings for each build of the core library. This ensures that we always have the latest bindings, and feels way more natural.

This is what the project is about in a nutshell. Stay tuned for the upcoming articles!
